# Single Page Design Madness #

A few days passed, a couple lessons learned. I promised myself not to spend too much time trying to make something perfect, but rather keep a _lean approach_ and moving forward.

So far, and _as expected_, I've implemented markdown in the client-side, but while implementing this I also spent a good deal of time fine-tuning the site's design. What I changed is the way in which I was going to _constraint browser support_.

## Not so progressive Enhancement ##

> Hey, this is a technical blog, I don't need no stinkin' IE.

I'll probably try and support **IE 10**, but that's as far as I'm willing to go. Things like `localStorage` and `history` are supported by _IE8+_, _IE10+_ respectively, and I didn't want to spend any time looking for hot fixing them in earlier versions of _IE_ just yet.

When I first though about this project I wanted it to be mobile first, but in order to publish a working version early in 2013 rather than later, I'll be dedicating myself to the mobile aspect later on, though I did all my designing in a mobile-conscious manner.

As I went along this past couple of days, I focused on two things.

- Front-end **design**, which got to a point where I'm pretty comfortable at
- The way in which I'm going to handle the fact that the page is going to behave (given that the idea is to use a **single-page** approach)

## Front-end design ##

On the HTML side of things, I'm really enjoying [**jade**](http://jade-lang.com/), it definitely sped up my productivity, and thirty minutes into development I felt really comfortable about it. I feel it's the perfect fit for _Node_. The single think I like the most is how I write my classes and IDs in the same way I write CSS selectors. So if you haven't yet, don't be so skeptical about giving a try, like I was. It's awesome.

I thought about trying out [**SASS**](http://sass-lang.com/), but I'm not really a fan of their propietary syntax, and [**LESS**](http://lesscss.org/) was so much easier to install. So [**LESS**](http://lesscss.org/) it is.

Other than that, _I'm not really a fan of using CSS frameworks_, so I did most of it by hand, or copying from older projects, which always comes in handy.

I tried to keep my CSS as reusable as posible, so I implemented common styles for my buttons, headings, and inputs, which will definitely help in any upcoming additions to the site.

Since I suck so much at picking color schemes, and the [**MongoDB site**](http://www.mongodb.org/) is pretty, I took their color scheme for simplicity.

I didn't pick a code prettify scheme yet for `code` blocks, mostly because I couldn't find a decent one.

> I'll settle on implementing a color scheme for code blocks by myself, once I get around to it though. It's not an immediate concern anyways.

## Client-side templates ##

In the beginning I was certain I wanted some sort of lightweight templating engine to handle my single-page design requirements. I'm liking the solution at which I've arrived a lot, so I figured I'd write about it.

The entire site is laid out in a single page, which contains the layout and includes every _view template_ that can be rendered, but initially hidden.

For example, lets talk about the template to post a new blog entry. **entry.jade**

In the page, I include the template as such:

    include templates/entry

	script(src='/js/entry.js')

This is of course, not as scalable as I'd like it to be, but I didn't take the time, _yet_, to search for and implement a proper _asset management system_, which would be the appropriate solution to keep view templates _self contained_.

I'm not exactly sure going forward how I'm going to handle templates that actually require a view model, but for now, a **jade** template will do just fine.

This is, as of right now, **entry.jade**:

	section#entry-template.template(data-class='entry-writing')
		form#entry-editor(method='POST',action='/write-entry')
		  div#entry-title-editor
			label(for='entry-title')='Title'
			input#entry-title(type='text',name='entry.title')

		  div#wmd-button-bar-brief.wmd-button-bar
		  div
			textarea#wmd-input-brief.wmd-input.entry-brief(name='entry.brief')

		  div#wmd-button-bar-text.wmd-button-bar
		  div
			textarea#wmd-input-text.wmd-input.entry-text(name='entry.text')

		  article.blog-entry
			header.blog-entry-title
			section#wmd-preview-brief.blog-entry-brief
			section#wmd-preview-text.blog-entry-text

		  div#entry-editor-buttons
			input(type='submit',value='Post')

My templating engine will have to deal with _displaying_ or _hiding_ the template as required, through a simple yet powerful system I defined.

The client-side **markdown** implementation is not the topic in discussion, so I'll refrain from posting the entire **entry.js** for now, instead referring to the snippet that registers the template with the templating engine.

    nbrut.tt.add({
        key: 'entry-editor',
        alias: '/write-entry',
        trigger: '#write-entry',
        source: '#entry-template',
        title: { value: 'New Post', formatted: true },
        onAfterActivate: onAfterActivate
    });

This seemingly innocent function call does a few things. The most important of them are parsing the **DOM** for the template and storing it in a key value dictionary, alongside the provided settings.

	function read(template) {
		var s = $(template.source);
		if (s.length !== 1){
			throw new Error('template source not unique.');
		}
		var css = s.data('class');
		var html = s.remove().html();

		template.dom = {
			html: html,
			css: css
		};
	}

Then it's simply stored in the dictionary:

    templates[settings.key] = settings;
	
And now we can _activate_ the template at any time, making it visible:

    nbrut.tt.activate('entry-editor');

Forcing people to use the _Javascript_ console isn't what I had in mind, so I naturally added a click handler to _activate_ the template:

	trigger.on('click', function(e){
		if (e.which === 1){ // left-click
			activate(settings.key);
			return false;
		}
	});

The point of using the `which` property is that I'm a _huge_ fan of opening new tabs for just about anything using my mouse wheel, and it infuriates me when I can't do that.

Ultimately, when you click on the button, and a template is to be _activated_, a few things happen.

	function activate(key) {
		var template = templates[key];
		if (template === undefined) {
			template = templates['404']; // fall back to 404.
		}

		if(!template.initialized){
			template.initialized = true;
			template.initialize();
		}

		if(template.container in active) {
			if(active[template.container] === template && !template.selfCleanup) {
				return; // already active.
			} else {
				deactivateContainer(template.container); // clean-up.
			}
		}

		activateTemplate(template); // set-up.

		template.onAfterActivate();
	}

We'll come back to the first if clause later. The template initialization is going to prove useful when some sort of one-time preparation for a particular template is required.

The third if clause introduces a new dictionary, the `active` dictionary. This one keeps track of which template is _active_ in each container managed by the templating engine. If the container is _active_, then it gets deactivated, which is a glorified way of saying the container is emptied.

In the rare case where the template doesn't need to refresh itself if it's already active, we terminate early.
	
Once the template is defined, initialized, and the container is ready, the template is set up, and then any _post-activation callback_ that has been provided, executes.
















