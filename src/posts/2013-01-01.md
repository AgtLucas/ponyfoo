# Javascript Javascript Javascript #

In my previous installment, I _prognosticated_ the discussion topic for this post series.

> In the next post series I'll delve into **MongoDB**, how to pair it with **Node**, and figuring out _how to communicate_ across all the application layers.

When it finally came to receiving the user input _Markdown_ produced on the client-side, and persisting it in the database, I realized I knew nothing about _Node.JS_. As I start writing this down, I realize I'm going to need to address some **more fundamental issues** before diving into _Node_.

I've read a few articles about _Node_ and _MongoDB_, but I hadn't really had any **practical experience** yet. I asked myself a few questions, and I feel like _I need to answer at least some of them before going forward_.

- How I would prevent or mitigate _over-posting_ issues?
- How am I going to perform **model validation**?
- How am I going to **separate concerns**?
- How am I going to **structure the application**? I probably should refer to a framework such as [Backbone.JS](http://backbonejs.org/ "Backbone.JS"), [Knockout.JS](http://knockoutjs.com/ "Knockout.JS"), or the like.
- Am I going to use the native _MongoDB_ [driver](http://www.mongodb.org/display/DOCS/Drivers)? Am I going to find [Mongoose ODM](http://mongoosejs.com/ "Mongoose Object Document Mapper") useful at all?
- Lastly, _how the **heck** am I going to render views that require a model_? Will I pair my templating engine with some other [templating](http://mustache.github.com/ "Mustache") [language](http://handlebarsjs.com/ "Handlebars")? Will my implementation do _just fine_ on its own?

> I sifted through [Learning Node](http://www.amazon.com/dp/1449323073 "Learning Node, O'Reiley, Aug 2012"), it serves as a pretty decent **introductory crash-course** and it answered the most basic questions I had.

# Refactoring Node.JS #

The template I started off with had just a `server.js` file that contained everything server-side: http server configuration, error handling, routing, route behavior, etc. I want a more **robust separation of concerns** going forward.

After going through the book, I formed a good idea of how I wanted to structure the server application.

The first thing I'm going to do is to **modularize** the application, I'll _separate concerns_ by having routing modules, controllers, and models, all in _separate logical files_.

## [module.exports](http://nodejs.org/api/modules.html "Node.JS docs") in Node.JS ##

Node.JS has a cute way of separating concerns in what's called _modules_. Modules is **self-contained** and exposes an API providing access to explicitly defined methods.

Here's an example **dependency.js**:

	var uid = 0; // local
	
	module.exports.startsWith = function(str, text){
		return str.indexOf(text) === 0;
	};
	
	module.exports.uid = function(){
		return ++uid;
	};
	
In your **server.js**, you would reference it like this:

	var dep = require('./dependency.js'),
		model = {
		sn: dep.uid();
		text: 'dependency flavored model'		
	};

	// ...
	
Not the best of examples, but you get the idea.  

## Routing and Controller Actions ##

Lets examine a more practical example, I want to have my routing defined somewhere else, rather than directly on **server.js**, so I'll replace my routes declaration with the following call, and defer the implementation to another file:

	require('/routing/core.js')(server);
   
With that simple statement I can pass the `server` object, and handle any routing directly in my self-contained module.

	module.exports = function(server){
		server.get('/*', function(req,res){
			res.render('site.jade');
		});

		server.post('/write-entry', function(req,res){
			console.log(req.body.entry);
			res.end();
		});
	};

This is pretty awesome, but all I really want from my routes is to _juggle request parameters around_, and I'll leave any real processing to the _controllers_. The `main` controller will be a really thin one:

	module.exports = {
		get: function(req,res){
			res.render('site.jade');
		}
	};
	
For the endpoint previously referred to as `POST /write-entry`, I'll favor a more [RESTful](http://en.wikipedia.org/wiki/Representational_state_transfer "REST API definition") approach this time. The controller pretty much will remain unchanged:

	module.exports = {
		put: function(req,res){
			console.log(req.body.entry);
			res.end();
		}
	};

The routing module ends up being:

	var main = require('../controllers/main.js');
	var entry = require('../controllers/entry.js');

	module.exports = function(server){
		server.get('/*', main.get);

		server.put('/entry', entry.put);
	};
	
All this code might seem redundant at first, but it will gain value as our application grows.

> As you might have noticed, my attempt at being RESTful is hindered by the rich application structure where all `GET` requests serve the same `text/html` response. This could be easily be mitigated in the future by considering some other endpoint for any **non-static** resource, such as:

- **GET** http://coderant.com/api/1.0/entry _fetch_
- **PUT** http://coderant.com/api/1.0/entry _upsert_
- **DELETE** http://coderant.com/api/1.0/entry/:id _delete_ 

> I don't really mind this minor catch right now though, I'll do this some other time.

## Models in MongoDB, introducing [Mongoose](http://mongoosejs.com/ "Mongoose ODM") ##

So far we've covered _views_, _controllers_, _routes_, but we haven't actually done anything worthwhile in the server-side. Now we'll plunge into **MongoDB**. I decided to use **Mongoose** after exploring my options a little and realizing how _much simpler_ my development would be having it around.

### Setting up the database environment ###










